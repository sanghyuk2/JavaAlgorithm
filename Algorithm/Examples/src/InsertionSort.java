/* 문제1)
다음의 숫자들을 오름차순으로 정렬하는 프로그램을 작성하세요
1 10 5 8 7 6 4 3 2 9
 */
public class InsertionSort {
    public static void main(String[] args) {
        int j,temp = 0;
        int[] array = {1, 10, 5, 8, 7, 6, 4, 3, 2, 9};

        for(int i = 0; i < 9; i++) {
            //현재 정렬할 원소를 선택해서 적절한 위치에 삽입할 수 있도록 함.
            //현재 원소의 위치 왼쪽에 있는 수들은 정렬되어있다고 '가정'을 하기 때문에 멈출 수 있는 위치를 알 수 있다.
            j = i;
            //j를 1씩 빼가면서 왼쪽에 있는 값이 더 크다면 위치를 바꾼다.
            while(array[j] > array[j+1]) {
                temp = array[j];
                array[j] = array[j+1];
                array[j+1] = temp;
                j--;
            }
        }

        for(int i = 0; i < 10; i++) {
            System.out.print(array[i]);
        }
    }
}

/*
삽입 정렬은
소스 코드 상에서 반복문이 두 번 사용되었다는 점에서,
즉, 범위가 1,2,3 이런식으로 순차적으로 진행한다는 점에서 선택/버블 정렬과 마찬가지로
10 + 9 + 8 ... + 1 이기에
시간 복잡도는 O(N^2)
하지만 실제로는 삽입 정렬의 연산 수가 가장 적게 일어난다는 점에서 선택/버블 정렬보다 효율적이다.

다음의 숫자들을 오름차순으로 정렬하세요
2 3 4 5 6 7 8 9 10 1

위와 같이 거의 정렬이 완성되어 있는 상태에서는 삽입 정렬이 굉장히 빠르다.
3의 경우 그대로, 4의 경우도 그대로.. 10의 경우 까지도 그대로이다.
즉 연산이 1번씩만 이루어진다.
1의 경우만 적절한 위치에 이동하는 연산이 필요하다.

'거의 정렬된' 상태라면 어떤 알고리즘보다도 빠르다라는 특징을 가지고 있다.
이유는 앞의 수들은 이미 정렬이 되어있다고 '가정' 하기 때문이다.
 */